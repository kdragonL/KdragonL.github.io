---
layout: post
title: Modern_CPP_book_01
---

피처 코츠슐링 / 모던C++입문, 엔지니어, 프로그래머를 위한 C++11/14입문

## 2장 : 클래스

#### 2.2.4 : static (혼동하지 말자)
  - 멤버의 static은 클래스가(object가 아님!) 하나만 가지는 것이며, 구현부에서 반드시 초기화가 필요하다.
  - static메쏘드는 객체 생성하지 않고도 클래스 이름만으로도 호출이 가능하다. static 데이터에만 접근할 수 있고, static 메소드만 호출할 수 있다.   

#### 2.3 생성자 및 할당 연산자
- 2.3.1 : 생성자의 초기화 리스트 (initialization list)
  - 생성자 머리에 콜론과 함께 설정
  - 필요성 (반드시 써야 하는 상황) : 초기화리스트를 쓰면 객체 생성과 동시에(혹은 이전에?) 처리한다고 이해하는 것이 낫다. 
    1. 상수멤버 : static이 아님. 각 object마다 서로 다른 상수를 갖는 것. object의 생명주기 내에서만 상수역할을 하는 것이다. 
    2. 레퍼런스 멤버 : 무언가를 가리키기는 해야 되니까. 바라볼 주소가 필요하다. 
    3. 객체 내 다른 객체(포인터가 아닐 경우) : 생성자 code가 execution되는 시점은 멤버가 생성되는 시점보다 이미 늦다. 
      - 책 본문의 설명 : '생성자 본문에 도달하기 전에 모든 멤버 변수를 구성하므로..'
      - 인터넷 어디에선가 : '생성자 내부에서 멤버 오브젝트 생성자 호출해봐야 그냥 지역변수가 하나 생성될 뿐 아무런 의미가 없다..'
      - **멤버 오브젝트의 클래스가 디폴트생성자가 없으면 오류 난다. 그럼 있으면... 써도 되는건가?**
    4. 상속받은 멤버 : 부모생성자가 먼저 호출되기 때문이다(?)
    // 레퍼런스는 몇 바이트인가? : 표준상은 메모리 공간 자체가 없으나, 컴파일러 재량에 따라 포인터와 같이 되기도. 
  - 효율성 : 초기화리스트를 사용하지 않을 경우, 메모리 공간이 먼저 만들어지고(=디폴트생성자가 한 번 작동한 후) 여기에 값을 대입(operator 연산)하므로. 그런데 초기화리스트 사용하면, 클래스 생성 되면서 한 번의 초기화만 이루어진다. **(어셈으로 한 번 확인해보면 좋을 듯 하다)**
  ```cpp
  complex(double rnew, double inew) : r(rnew), i(inew)
  ```

- 2.3.1.1 : 디폴트 생성자
  - 주로 모든 멤버를 0, -1, NULL, 빈문자열로 초기화한다. 즉, 디폴트 생성자의 임무는 쓰레기는 치우는 것. 
    (http://soen.kr/lecture/ccpp/cpp3/26-2-1.htm)
  - 별도의 생성자가 있다면, 컴파일러는 디폴트 생성자를 만들지 않는다.
  
- 2.3.1.2 : 복사 생성자
  - 사용자가 복사 생성자를 작성하지 않으면, 컴파일러가 표준적으로 복사 생성자를 생성. 
  - 클래스에 포인터가 포함되어 있으면, 디폴트 복사 생성자가 자동으로 만들어지지 않는다. 데이터를 복사한 게 아니라 주소를 복사한 것이기 때문에. 또한, 런타임 시점에 동일한 메모리를 두 번 해제하려는 문제가 발생할 수 있다. *(주의 : 복사생성자의 인수로 포인터를 쓰면 안 된다는 게 아니다.)*
  - 복사 생성자는 인수를 값으로(call by value) 전달할 수 없다. 값의 복사를 위해서 또 다시 복사생성자를 호출하고, 이 복사생성자는 또 다시 객체 복사하고 다시 호출하고.. 이렇게 무한루프 발생하기 때문에. 
  
- 2.3.1.3 : 명시적 생성자
  - 암시적 변환은, 필요한 타입과 다른 타입을 제공할 때 발생한다. 어떤 함수 호출 시의 파라미터가 지정된 것과 다른데(오버로드가 가능할 때) 애초에 정의된 파라미터 타입의 생성자가, 다르게 들어온 파라미터의 타입을 허용하는 생성자가 있으면, 임의로 생성하는 것.
  - explicit로 피해야 되는 상황이 있다. 
  
- 2.3.1.4 : 생성자 위임
  - 생성자에서 다른 생성자를 호출한다. 아래의 예를 살펴보자 (출처 : http://www.qaupot.com/wordpress/?p=2385)
  - Coordinate를 1차원으로, 2차원으로 혹은 3, 4차원으로 쓸 수도 있다. 인수를 4개 받는 4차원의 생성자에서 4개 멤버에 인수 4개를 일일이 할당하는 것 보다는, 아래처럼 생성자가 생성자를 호출하는 방식이면 간단하게 해결 가능하다. 이보다 더욱 복잡한 상황을 가정한다면, 효율적인 방식이다. 
  ``` cpp
      class Coordinate
      {
      public:
          int w, x, y, z;

          Coordinate(int w) 
          { 
              printf("Call 1D\n"); 
              this->w = w;
          }
          Coordinate(int w, int x) : Coordinate(w)
          { 
              printf("Call 2D\n");
              this->x = x; 
          }
          Coordinate(int w, int x, int y) : Coordinate(w,x) 
          { 
              printf("Call 3D\n");
              this->y = y;
          }
          Coordinate(int w, int x, int y, int z) : Coordinate(w, x, y)
          {
              printf("Call 4D\n");
              this->z = z; 
          }
      };

      int main(int argc, char** argv)
      {
          Coordinate c(1, 2, 3, 4);
      }
  ```


---------- 아래는 템플릿 -------------
- 2.2.2 템플릿
  - 연산 결과와 같은 임시 변수들은 레퍼런스로 전달할 수 없다.
  ```cpp 
  increment(i-9); // 오류 발생한다. 
  ```
  - 인수 목록의 끝에서만 여러 개의 기본값을 선언할 수 있다. 즉, 기본값을 갖는 인수 뒤에는 기본값이 없는 인수를 가질 수 없다.
  
- 2.2.3 : 양식템플릿
  - Overload Resolution의 작동 방식
    1. 인수 ㅌ아비과 정확히 일치하는 오버로드 있다면 취한다. 그렇지 않다면
    2. 변환후 일치하는 오버로드 있는가?
        - 0개 : 오류. 일치하는 함수 찾을 수 없다.
        - 1개 : 해당 오버로드를 취한다
  - 함수 오버로드는 시그니처가 서로 달라야 한다. 
    - 시그니처 : 1.함수의 이름 / 2. 인자의 개수 / 3. 인자의 타입
    
 
