---
layout: post
title: Modern_CPP_book_01
---

피처 코츠슐링 / 모던C++입문, 엔지니어, 프로그래머를 위한 C++11/14입문

### 2장 : 클래스

- 2.2.4 : static (혼동하지 말자)
  - 멤버의 static은 클래스가(object가 아님!) 하나만 가지는 것이며, 구현부에서 반드시 초기화가 필요하다.
  - static메쏘드는 객체 생성하지 않고도 클래스 이름만으로도 호출이 가능하다. static 데이터에만 접근할 수 있고, static 메소드만 호출할 수 있다.   

- 2.3.1 : 생성자의 초기화 리스트 (initialization list)
  - 생성자 머리에 콜론과 함께 설정
  - 필요성 (반드시 써야 하는 상황) : 초기화리스트를 쓰면 객체 생성과 동시에(혹은 이전에?) 처리한다고 이해하는 것이 낫다. 
    1. 상수멤버 : static이 아님. 각 object마다 서로 다른 상수를 갖는 것. object의 생명주기 내에서만 상수역할을 하는 것이다. 
    2. 레퍼런스 멤버 : 무언가를 가리키기는 해야 되니까. 바라볼 주소가 필요하다. 
    3. 객체 내 다른 객체(포인터가 아닐 경우) : 생성자 code가 execution되는 시점은 멤버가 생성되는 시점보다 이미 늦다. 
      - 책 본문의 설명 : '생성자 본문에 도달하기 전에 모든 멤버 변수를 구성하므로..'
      - 인터넷 어디에선가 : '생성자 내부에서 멤버 오브젝트 생성자 호출해봐야 그냥 지역변수가 하나 생성될 뿐 아무런 의미가 없다..'
      - **멤버 오브젝트의 클래스가 디폴트생성자가 없으면 오류 난다. 그럼 있으면... 써도 되는건가?**
    4. 상속받은 멤버 : 부모생성자가 먼저 호출되기 때문이다(?)
    // 레퍼런스는 몇 바이트인가? : 표준상은 메모리 공간 자체가 없으나, 컴파일러 재량에 따라 포인터와 같이 되기도. 
  - 효율성 : 초기화리스트를 사용하지 않을 경우, 메모리 공간이 먼저 만들어지고(=디폴트생성자가 한 번 작동한 후) 여기에 값을 대입(operator 연산)하므로. 그런데 초기화리스트 사용하면, 클래스 생성 되면서 한 번의 초기화만 이루어진다. **(어셈으로 한 번 확인해보면 좋을 듯 하다)**
  ```cpp
  complex(double rnew, double inew) : r(rnew), i(inew)
  ```

- 2.3.1.1 : 디폴트 생성자
  - 주로 모든 멤버를 0, -1, NULL, 빈문자열로 초기화한다. 즉, 디폴트 생성자의 임무는 쓰레기는 치우는 것. 
    (http://soen.kr/lecture/ccpp/cpp3/26-2-1.htm)



---------- 아래는 템플릿 -------------
- 2.2.2 템플릿
  - 연산 결과와 같은 임시 변수들은 레퍼런스로 전달할 수 없다.
  ```cpp 
  increment(i-9); // 오류 발생한다. 
  ```
  - 인수 목록의 끝에서만 여러 개의 기본값을 선언할 수 있다. 즉, 기본값을 갖는 인수 뒤에는 기본값이 없는 인수를 가질 수 없다.
 
- 2.2.3 : 양식템플릿
  - Overload Resolution의 작동 방식
    1. 인수 ㅌ아비과 정확히 일치하는 오버로드 있다면 취한다. 그렇지 않다면
    2. 변환후 일치하는 오버로드 있는가?
        - 0개 : 오류. 일치하는 함수 찾을 수 없다.
        - 1개 : 해당 오버로드를 취한다
  - 함수 오버로드는 시그니처가 서로 달라야 한다. 
    - 시그니처 : 1.함수의 이름 / 2. 인자의 개수 / 3. 인자의 타입
    
 
